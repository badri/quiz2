<?php

/**
 * @file
 * Provides a framework for creating and managing question types.
 */


/**
 * Implements hook_ctools_plugin_type().
 */
function question_ctools_plugin_type() {
  return array(
    'question_attempt_type' => array(
      'use hooks' => FALSE,
      'classes' => array('class'),
    ),
    'question_type' => array(
      'use hooks' => FALSE,
      'classes' => array('class'),
    ),
  );
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function question_ctools_plugin_directory($module, $plugin) {
  if ($module == 'question') {
    return 'includes/plugins/' . $plugin;
  }
}

/**
 * Get the available question attempt type plugins.
 */
function question_attempt_get_type_plugins() {
  ctools_include('plugins');
  $plugins = ctools_get_plugins('question', 'question_attempt_type');
  foreach ($plugins as $key => $plugin) {
    if (!class_exists($plugin['class'])) {
      // Invalid class specified.
      unset($plugins[$key]);
      continue;
    }
    $r = new ReflectionClass($plugin['class']);
    if (!$r->hasMethod('isValid') || !call_user_func(array($plugin['class'], 'isValid'))) {
      // Invalid plugin specified.
      unset($plugins[$key]);
      continue;
    }
  }
  uasort($plugins, 'ctools_plugin_sort');
  return $plugins;
}

/**
 * Get the available question type plugins.
 */
function question_get_type_plugins() {
  ctools_include('plugins');
  $plugins = ctools_get_plugins('question', 'question_type');
  foreach ($plugins as $key => $plugin) {
    if (!class_exists($plugin['class'])) {
      // Invalid class specified.
      unset($plugins[$key]);
      continue;
    }
    $r = new ReflectionClass($plugin['class']);
    if (!$r->hasMethod('isValid') || !call_user_func(array($plugin['class'], 'isValid'))) {
      // Invalid plugin specified.
      unset($plugins[$key]);
      continue;
    }
  }
  uasort($plugins, 'ctools_plugin_sort');
  return $plugins;
}

// TODO:
// 1. add admin UI
// 2. views bulk ops interface
/**
 * Implements hook_entity_info().
 */
function question_entity_info() {
  $return = array(
    'question_attempt' => array(
      'label' => t('Question Attempt Type'),
      //TODO: we're not inheriting it yet
      'controller class' => 'EntityBundlePluginEntityController',
      'base table' => 'question_attempt',
      'module' => 'question',
      'bundle plugin' => array(
        'plugin type' => 'question_attempt_type',
        'broken class' => 'QuestionAttemptBroken',
      ),
      'fieldable' => TRUE,
      'entity keys' => array(
        'id' => 'question_attempt_id',
        'bundle' => 'type',
      ),
      'view modes' => array(
        'full' => array(
          'label' => t('Full'),
          'custom settings' => TRUE,
        ),
        'line_item' => array(
          'label' => t('Line item summary'),
          'custom settings' => TRUE,
        ),
      ),
      'access callback' => 'question_attempt_access',
      'access arguments' => array(
        'user key' => 'uid',
      ),
    ),
    'question' => array(
      'label' => t('Question Type'),
      //TODO: we're not inheriting it yet
      'controller class' => 'EntityBundlePluginEntityController',
      'base table' => 'question',
      'module' => 'question',
      'bundle plugin' => array(
        'plugin type' => 'question_type',
        'broken class' => 'QuestionBroken',
      ),
      'fieldable' => TRUE,
      'entity keys' => array(
        'id' => 'question_id',
        'bundle' => 'type',
      ),
      'view modes' => array(
        'full' => array(
          'label' => t('Full'),
          'custom settings' => TRUE,
        ),
        'line_item' => array(
          'label' => t('Line item summary'),
          'custom settings' => TRUE,
        ),
      ),
      'access callback' => 'question_access',
      'access arguments' => array(
        'user key' => 'uid',
      ),
    ),
  );
  foreach (question_attempt_get_type_plugins() as $plugin_name => $plugin) {
    $return['question_attempt']['bundles'][$plugin_name] = array(
      'label' => $plugin['title'],
    );
  }

  foreach (question_get_type_plugins() as $plugin_name => $plugin) {
    $return['question']['bundles'][$plugin_name] = array(
      'label' => $plugin['title'],
    );
  }

  return $return;
}

/**
 * Implements hook_permission().
 */
function question_permission() {
  return array(
    'attempt quiz' => array(
      'title' => t('Attempt Quiz'),
    ),
  );
}


function question_attempt_access($op, $question_attempt = NULL, $account = NULL) {
  if (!isset($account)) {
    $account = $GLOBALS['user'];
  }
  //TODO:only give access if the user has access to take the quiz
  // or is the administrator of the quiz
  return TRUE;
}

function question_access($op, $question = NULL, $account = NULL) {
  if (!isset($account)) {
    $account = $GLOBALS['user'];
  }
  //TODO:only give access if the user has created this question or is admin
  return TRUE;
}

/**
 * Implement hook_entity_property_info().
 */
function question_entity_property_info() {
  $info = array();
  $properties = &$info['question_attempt']['properties'];

  $properties['question_attempt_id'] = array(
    'type' => 'integer',
    'label' => t('Question Attempt ID'),
    'description' => t('Question Attempt id.'),
    'validation callback' => 'entity_metadata_validate_integer_positive',
    'schema field' => 'question_attempt_id',
  );

  $properties['type'] = array(
    'type' => 'token',
    'label' => t('Type'),
    'description' => t('The question attempt type'),
    'options list' => 'QuestionAttemptMetadataController::bundleOptionsList',
    'setter callback' => 'entity_property_verbatim_set',
    'required' => TRUE,
    'schema field' => 'type',
  );

  $properties['uid'] = array(
    'type' => 'user',
    'label' => t('Quiz Taker'),
    'description' => t('The person attempting the quiz.'),
    'setter callback' => 'entity_property_verbatim_set',
    'required' => TRUE,
    'schema field' => 'uid',
  );

  $properties['question'] = array(
    'type' => 'question',
    'label' => t('Product'),
    'description' => t('The question id being attempted.'),
    'setter callback' => 'entity_property_verbatim_set',
    'required' => TRUE,
    'schema field' => 'question',
  );

  $properties['attempted_time'] = array(
    'type' => 'date',
    'label' => t('Attempted Time'),
    'description' => t('The Unix timestamp when the question was attempted.'),
    'schema field' => 'attempted_time',
  );

  return $info;
}
